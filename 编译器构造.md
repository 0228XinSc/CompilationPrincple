# 编译器

为一个具体语言编写一个编译器是一个较为复杂的任务，需要耗费较多的时间，查阅学习各种书籍，整体完成后的代码量应该是不容小觑的。仅仅是完成一个简单的词法分析就需要400行代码完成，且还不是最终版本。

## 编译器构造

下图给出编译器的构造方式，分成两个部分。

**分析部分（前端）：**由词法分析、语法分析、语义分析所构成的分析部分的作用是对源程序文本进行分析，最后生成中间代码。词法分析将源程序的文法分析出文法类别码提供给语法分析程序，语法分析将类别码进一步组合成语法成分信息，如<CompUnit>。语义分析对语法成分进行进一步的分析，识别出具体含义并且生成中间代码。

**综合部分（后端）：**通过代码生成和代码优化生成目标程序。代码生成部分将源程序的中间形式转换为汇编语言或者机器语言。进行代码优化的主要目的是要获得更高效的目标程序，在确保源代码功能不变的前提下，使目标代码更简短，减少存储空间和运行时间。

![image-20211109213828948](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109213828948.png)

### 分析过程中重要的定义

1. 类别码

   ![image-20211109221016726](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109221016726.png)

2. 文法

   ![image-20211109221241189](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109221241189.png)

   ![image-20211109221512520](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109221512520.png)

   ![image-20211109221542802](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109221542802.png)

## 词法分析文档

**主要功能**

​	词法分析逐个读取源文件的字符，根据当前字符对类别码进行识别。同时将字符组合成单词进行输出。还要对数字常数完成数字字符到十进制字符的转换。同时删去空格字符和注释。

**词法分析实现**

采用词法分析单独作为一遍实现，将分析出的类别码放到一个`int SymbolList[100000]`数组中记录,以供语法分析使用。

利用`extern map<int,string> MapSymbol`对类别码和对应编号一一对应，string语句既是最后输出语句。

**类别码对应编号**

```
#define IDENFR 1
#define INTCON 2
#define STRCON 3
#define MAINTK 4
#define CONSTTK 5
#define INTTK 6
#define BREAKTK 7
#define CONTINUETK 8
#define IFTK 9
#define ELSETK 10
#define NOT 11
#define AND 12
#define OR 13
#define WHILETK 14
#define GETINTTK 15
#define PRINTFTK 16
#define RETURNTK 17
#define PLUS 18
#define MINU 19
#define VOIDTK 20
#define MULT 21
#define DIV 22
#define MOD 23
#define LSS 24
#define LEQ 25
#define GRE 26
#define GEQ 27
#define EQL 28
#define NEQ 29
#define ASSIGN 30
#define SEMICN 31
#define COMMA 32
#define LPARENT 33
#define RPARENT 34
#define LBRACK 35
#define RBRACK 36
#define LBRACE 37
#define RBRACE 38
#define ERROR 39
#define NOTES 40
```

**通过画出文法状态图，知道各类型单词的判断过程。**

1. 保留字（字母构成）和标识符（由字母或`_`开始，可以包含数字字母或者 `_` ）过程

   由字母或者_开始，向后继续查找字母或者数字或者` _`,同时将字符组合起来。通过对`token`字符串和保留字判断，设置对应`symbol`类别码，若不是保留字，即是标识符`IDENFR`。

2. 数字过程

   由数字开始，继续查找数字，整合成数字字符串，转化成数字。

3. 注释过程

   `/* */`注释

   嵌套在判断除号过程中，初始实现思想是当遇到`/*`注释开始，遇到`*/`注释结束。所以需要每次判断当前字符位置/和上一个字符位置*。

   不过遇到这种情况

   ```
    /*/*
        * /testfile created with ``heart'' by 19373384
        *
       /
       */
   ```

   其中/*/也会导致注释结束，所以再次多向前读取一个字符进行判断

   `//`注释

   判断注释到遇到`\n`结束

4. 其他字符

   其他字符直接设置对应的类别码就行。

**重要约束**

​		在进入各类型识别函数之前，获得新的字符，在结束识别函数时，对当前字符进行更新。

## 语法分析文档

​		语法分析是编译过程的核心部分。语法分析的任务是按照文法，从源程序类别码中识别出个类语法程序，同时进行语法检查，为语义和生成代码做准备。

​		本次采用递归下降分析法，对文法的每个非终结符都编写对应的子程序，以完成非终结符号所对应的语法成分和识别任务。某个非终结符号的语法分析子程序的功能是，用该非终结符的规则的右部符号串去匹配输入符号串。

​		整个语法分析从`CompUnit()`函数进入，然后对之后的类别码进行分析。进入一个子程序需要判断FIRST集合，甚至有些语法成分分析的进入，需要预读很多位类别码才能判断。对于BFS中{}一般通过while实现，[]通过if进行实现。

​		对于具有左递归的文法需要利用相应规则进行改写。

**左递归文法的改写**	

```
AddExp → MulExp | AddExp ('+' | '−') MulExp
-》
AddExp → MulExp { ('+' | '−') MulExp }

RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
-》
RelExp → RelExp { ('<' | '>' | '<=' | '>=') RelExp }

EqExp → RelExp | EqExp ('==' | '!=') RelExp
-》
EqExp → EqExp { ('==' | '!=') EqExp}

LAndExp → EqExp | LAndExp '&&' EqExp
-》
LAndExp → EqExp { '&&' EqExp }

LOrExp → LAndExp | LOrExp '||' LAndExp
-》
LOrExp → LAndExp { '||' LAndExp }
```



**重要约束**

虽然有些语法成分不需要输出，但不要擅自省略其对应的子程序函数。否则对整体文法的正确性会有很大影响。

当调用某个分析子程序时，他分析的第一符号`SymbolList[CurSymPos]`；在分析子程序返回报告成功前，将CurSymPos的位置+1，即获得下一个类别码。

**代码修改**

将省略的语法成分`BType` 补全

## 错误处理

​		在程序编写完成后，每一个程序员都无法保证自己的程序完全符合语法、语义规则和其他的一些规定。这些错误如果没有编译器给出的相关提示，想要修改就需要耗费相当多的时间，拖慢编程的效率和准确性。所以编译器对程序的错误处理就显得至关重要。

#### 程序设计要求

​		根据给定文法设计相关的错误处理程序，能够**将违反常见语法和语义规则的错误反馈给编码者**，同时能进行**错误局部化处理**。反馈方式为当出现错误后，输出相应的错误类别码和错误出现位置所在的行号。不过在本次实验之后，错误处理最好能够详细的说明错误信息，能够帮助完善编译器设计与开发。

​		对于语法错误，即违反文法定义的编码方式。

​		对于语义错误，可详见文法定义与相关说明的语义约束部分，还包含超越具体计算机系统的限制。如顶层变量/常量声明，函数定义时不能重复定义同名标识符，此时还需要**符号表管理**来帮助判断是否重名。

​		对于错误局部化处理，解释是当程序发现错误后，尽可能将错误限制在一个局部的范围内，避免错误扩散和影响程序其它部分的分析和检查。

​	**错误类别码**：

​		用做错误类型的识别，以及输出。

​	<img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211019162028729.png" alt="image-20211019162028729" style="zoom: 80%;" />

>

##### 哪些文法需要填表

```
/*声明*/
ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal
VarDef → Ident { '[' ConstExp ']' }| Ident { '[' ConstExp ']' } '=' InitVal
FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
/*调用*/
LVal → Ident {'[' Exp ']'}
UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')'
```



> ##### 疑惑
>
> - 形参是多维数组时， int [] [`Constexp`] 的`Constexp`会不会出现ident 。
>
>   
>

#### 错误处理实现

在用递归下降分析法进行语法分析是，一旦检查出错误就将错误性质送给变量cx（行号，错误类型），然后转出错处理,根据cx输出错误的类型和对应的行号，并且还能保证能够运行之后的程序。

对以上错误类型进行处理。

首先将错误分类成语法错误和语义错误。语法错误包含以下几项

##### 语法错误

![image-20211026182703756](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211026182703756.png)

###### 缺少分号

同下

###### 缺少右小括号

不仅仅要输出出错的位置，还要对错误进行改正，防止影响之后的程序错误判断。比如if(`)`缺少，会导致跳出if else整体判断，if之后若紧跟else，那么无法对else进行分析，导致死循环。要进行错误修正。修正后返回语句的开始进行判断。

在返回语句开始的同时需要注意语句中是否会有函数的声明，即是否会造成标识符入符号表栈，如果有，需要将标识符弹出。

突然想到好像不用错误修正，直接在error后继续本应该的判断就行。

###### 缺少右中括号

实现以上三中缺少对应右部匹配符号的错误处理，当前`SymbolList[CurSymPos]`类别码已经找不到正确的引号小括号中括号。

###### 非法符号实现

出现位置，在`printf`语句的字符串中。`ForMatString` 字符串在词法分析中就已经被放入token中。可以在语法分析`ForMatString`函数中新建一个局部变量`ForMatStringFlag`局部变量对当前token进行判断，是否存在非法符号。

非法符号定义为：32，33，40-126之外的ASCII字符，若出现\则后边必须跟n

报错行号为`STRON`类别码对应的行号，即`SymbolListLine[CurSymPos]`

错误处理结束后，进行下一个字符的判断（当前是`strcon`如果不读下一个，那么跳出`formatstring`函数后，之后的递归下降判断无法通过，会导致死循环）

##### 语义错误

###### 名字重定义

![image-20211025215347372](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025215347372.png)

出现在变量常量函数函数参数的声明中，只需在插入符号函数中进行判断即可

> ？？？名字重定义后，不填入符号表，输出<ident>行号，也就是当前类别码位置地行号，还要进行什么操作，

###### 未定义的名字

![image-20211025232437555](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025232437555.png)

调用部分，符号表中是否有过声明，即是栈式符号表中是否有对应的标识符。

###### 函数参数个数不匹配

![image-20211025234313605](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025234313605.png)

需要对符号表进行增加，记录函数参数的个数，在调用的时候进行判断。新建一个结构体保存函数参数的个数和类型。在函数参数声明 和函数参数调用时进行调用。

声明时，在进入形参函数之前定义一个`PramNum`，将`int &PramNum `作为形参函数的形参，用来返回改变后的`ParmNum`值。

`UnaryExp`调用，首先不会知道标识符的数据类型，只有在栈中找到标识符的声明之后，获得标识符的数据类型。如果是函数标识符类型，获得其函数的形参个数`n`和声明标识符在符号表中的位置，将这些作为实参表的形参，在实参表函数中进行判断。对其后的n个标识符`即形参`和当前标识符之后的的`n`。对而标识符函数调用时，函数参数和函数个数在完成函数实参表时才能够获取到。

###### 函数参数类型不匹配

![image-20211027013334208](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211027013334208.png)

不应该是对函数名之后n个变量进行判断，符号表不能这样存储形参，因为在定义的函数结束后，除了函数名保存在栈符号表中外，其他局部变量全部弹出。在之后调用函数时，其形参已经不在符号表中。在其他信息结构体中添加新的数组，用来存储各个形参类型。在函数名对应位置的补充信息中的形参表收集从FuncFParams 获得的

令FuncFParams 改变ExtraSymbol，令FuncFParam返回DataType。

###### 不能改变常量的值

从Lval返回变量类型，对之后的等号进行判断

## 符号表管理

​		符号表适用于保存每个标识符及其属性信息的数据结构，在符号表的表型中登录标识符的属性。使用符号表能快速地找到每个标识符的表项并能快速存储和检索表项记录的数据信息。

​		在多变扫描的编译程序中，在词法分析阶段就将标识符填入符号表，标识符的其他属性则在语义分析和代码生成阶段填入。

### 符号表的构建方式

​		符号表的存取操作可能会花去编译期间很多的处理器时间，所以需要合理的选择符号表的组织形式，选择高效的填表查表方式，这样才能提高编译程序的工作效率。

#### 符号表结构

分成两个部分，**主要部分**

1.  `NameIndex`   变量名在`TokenList所有变量名数组`的位置
2. `IdentTypeId` 标识符类型
3. `DataTypeId `    数据类型
4. `LineNumIndex `   标识符在记录行号数组中的下标
5. **错误处理阶段**  `ExtraSymbol`指向其他函数补充信息的函数信息表指针
6. **代码生成阶段**  指向数组类型的数组向量表指针
7. **代码生成阶段**  `ObjectAddress`  目标地址，对于变量（包括形参名），应填入该变量（或形参）在运行栈S中分配存储单元的相对地址；对于函数名，应填入它们相应目标代码的入口地址。 

| token/Name | 标识符类型      | 数据类型        | 行号 | 补充符号表指针 |
| ---------- | --------------- | --------------- | ---- | -------------- |
|            | 函数 Func ---1  | int           0 |      |                |
|            | 常量 Const --2  | array1    1     |      |                |
|            | 变量 Var -----3 | array2    2     |      |                |
|            | 形参 Parm --4   | void        3   |      |                |

**其他信息部分：**

1. 记录形参个数，用于错误处理函数形参和实参之间的匹配
2. 记录形参的类型，作用同上



对于一些特殊的类型需要考虑更多的信息：

1. **数组**

   维数、上下界值

2. **函数**

   **形参个数**，形参类型，**实参个数**，实参类型，所在层次，函数返回值。

#### 符号表组织形式

​	采用栈式符号表进行组织，同时利用分程序索引表保存程序层次。

### 符号表典型操作

1. **填表**

   找到与标识符有关的文法，对标识符的信息进行分析，将新纪录推入栈顶单元即可。要考虑标识符在同一分程序同名情况。

   标识符Name，存放在TokenList string数组

2. **查表**

   需要将符号表填表和查表操作进一步独立

   什么情况下查表：

   ​		**声明部分**时：查询该标识符在所在程序单元`从栈式符号表栈顶到分程序索引表栈顶对应的栈式符号表位置`中是否存在同名的标识符，查表函数的形参为`token字符串`，函数类型`int`返回`同名标识符在栈式符号表的下标`或者`-1`。

   ​		**调用部分**：查询所在程序单元的符号表中是否存在同名的标识符，若存在，说明该标识符已声明；若不存在，继续向外层程序单元进行查询，直至到最外层单元仍未出现同名标识符时，说明该标识符未声明。

   ​		分程序的开始：执行定位操作

   ​		分程序的结束：执行重定位操作

3. **定位**

   分程序索引表的顶端填入新的分程序索引项。（即分程序头一个标识符在符号表的位置）

   定位时机在判断当前标识符是一个函数名时

   > 不能只考虑函数的定位和重定位，在while if else 等含有block的语句都能声明新的变量。可是while if else 都没有变量名 *如何记录变量名在栈中的位置*，while if else 都是语句在stmt 中的block 前进行定位，在block后进行重定位，即可

4. **重定位**

   清除刚刚被编译完的分程序在栈式符号表中的所有记录。

   考虑分程序符号表为空情况

   > //重定位时机在block `}`结束后,**错误**

>应该是{},之间一一对每次大括号都要定位，但是
>
>在函数结束时重定位，应该是funcdef }
>
>对于在main函数之前的函数的重定位情况

### 其他表格

#### 分程序索引表

数据结构：动态整型数组

#### 数组向量表

#### PCode目标代码表

数据结构为：

```c++
struct RunStack{
	int f;//对应pcode操作指令的操作码
	int x;//变量所在分程序层次
	int y;//变量值对应的存储相对地址
};
extern vector<RunStack> RunStack;
```



## 代码生成

实验要求：请在词法分析、语法分析及错误处理作业的基础上，为编译器实现语义分析、代码生成功能。本次实验设计以生成PCODE作为目标代码的编译器。

特别说明：本次作业是为了让同学们尽快实现一个完整的编译器，测试程序中仅涉及**常量声明、变量声明、读语句、写语句、赋值语句，加减乘除模除等运算语句、函数定义及调用语句**。在之前完成的语法分析的基础上，对文法进行修改，添加相应的语义动作子程序，在进行语法分析同时实现语义动作，生成与源程序语义对应的PCode指令序列，存入PCode代码表中。若想完成编译器的完美运行，仅生成中间代码是不够的，还需要对Pcode进行解释执行，即从PCode表中逐个取出指令，对相应数据（常量，变量，函数）进行存入，运算，调用等操作，获得代码执行最终结果。

### 语义分析及生成PCode

首先，将文法修改成对应的属性翻译文法，将每个子程序添加相应的继承属性和综合属性、语义动作程序，以生成Pcode指令序列。需要在原符号表的基础上，增加对变量常量数组相应数据的记录。修改后内容在前一部分 **符号表管理中展示**。

#### 改写成属性翻译文法

编译单元 CompUnit → {Decl} {FuncDef} MainFuncDef // 1.是否存在Decl 2.是否存在 FuncDef 

声明 Decl → ConstDecl | VarDecl // 覆盖两种声明 

常量声明 ConstDecl → 'const' BType ConstDef { ',' ConstDef } ';' // 1.花括号内重 复0次 2.花括号内重复多次 

基本类型 BType → 'int' // 存在即可 

常数定义 ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal // 包含普通变 量、⼀维数组、⼆维数组共三种情况 

常量初值 ConstInitVal → ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}' // 1.常表达式初值 2.⼀维数组初值 3.⼆维数组初值 

变量声明 VarDecl → BType VarDef { ',' VarDef } ';' // 1.花括号内重复0次 2.花括号内 重复多次 

变量定义 VarDef → Ident { '[' ConstExp ']' } // 包含普通变量、⼀维数组、⼆维数组定义 标识符Ident（需要覆盖的情况以注释形式给出）：

| Ident { '[' ConstExp ']' } '=' InitVal 

变量初值 InitVal → Exp | '{' [ InitVal { ',' InitVal } ] '}'// 1.表达式初值 2.⼀ 维数组初值 3.⼆维数组初值 

函数定义 FuncDef → FuncType Ident '(' [FuncFParams] ')' Block // 1.⽆形参 2.有形 参 

主函数定义 MainFuncDef → 'int' 'main' '(' ')' Block // 存在main函数 

函数类型 FuncType → 'void' | 'int' // 覆盖两种类型的函数 

函数形参表 FuncFParams → FuncFParam { ',' FuncFParam } // 1.花括号内重复0次 2.花括 号内重复多次 

函数形参 FuncFParam → BType Ident ['[' ']' { '[' ConstExp ']' }] // 1.普通变量 2.⼀维数组变量 3.⼆维数组变量 

语句块 Block → '{' { BlockItem } '}' // 1.花括号内重复0次 2.花括号内重复多次 

语句块项 BlockItem → Decl | Stmt // 覆盖两种语句块项 

语句 Stmt → LVal '=' Exp ';' // 每种类型的语句都要覆盖 

| [Exp] ';' //有⽆Exp两种情况 

| Block 

| 'if' '( Cond ')' Stmt [ 'else' Stmt ] // 1.有else 2.⽆else 

| 'while' '(' Cond ')' Stmt 

| 'break' ';' 

| 'continue' ';' 

| 'return' [Exp] ';' // 1.有Exp 2.⽆Exp 

| LVal = 'getint''('')'';' 

| 'printf''('FormatString{,Exp}')'';' // 1.有Exp 2.⽆Exp 

表达式 Exp → AddExp 注：SysY 表达式是int 型表达式 // 存在即可 

条件表达式 Cond → LOrExp // 存在即可 

左值表达式 LVal → Ident {'[' Exp ']'} //1.普通变量 2.⼀维数组 3.⼆维数组 

基本表达式 PrimaryExp → '(' Exp ')' | LVal | Number // 三种情况均需覆盖 数值 Number → IntConst // 存在即可 

⼀元表达式 UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' // 3种情况均需覆盖, 函数调⽤也需要覆盖FuncRParams的不同情况 | UnaryOp UnaryExp // 存在即可 

单⽬运算符 UnaryOp → '+' | '−' | '!' 注：'!'仅出现在条件表达式中 // 三种均需覆盖 

函数实参表 FuncRParams → Exp { ',' Exp } // 1.花括号内重复0次 2.花括号内重复多次 3. Exp需要覆盖数组传参和部分数组传参 

乘除模表达式 MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp // 1.UnaryExp 2.* 3./ 4.% 均需覆盖 

加减表达式 AddExp → MulExp | AddExp ('+' | '−') MulExp // 1.MulExp 2.+ 需覆盖 3.- 需覆盖 

关系表达式 RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp // 1.AddExp 2.< 3.> 4.<= 5.>= 均需覆盖 

相等性表达式 EqExp → RelExp | EqExp ('==' | '!=') RelExp // 1.RelExp 2.== 3.!= 均需覆盖 

逻辑与表达式 LAndExp → EqExp | LAndExp '&&' EqExp // 1.EqExp 2.&& 均需覆盖 

逻辑或表达式 LOrExp → LAndExp | LOrExp '||' LAndExp // 1.LAndExp 2.|| 均需覆盖 

常量表达式 ConstExp → AddExp 注：使⽤的Ident 必须是常量 // 存在即可

#### 声明语句的语义分析

##### 常量类型声明处理

> 常量声明 ConstDecl → 'const' BType`↑t` ConstDef`↓t` { ',' ConstDef`↓t` } ';'
>
> 基本类型 BType`↑t` → 'int'`↑t`  
>
> 常数定义 ConstDef`↓t` → Ident`↑n` { '[' ConstExp ']' }`↓t↑t` '=' ConstInitVal`↑c` `@insertSymbolList ↓t↓n↓c` 

**@insertSymbolList**: 把名字n，类型t 和常量表达式的值c 填入符号表中

##### 变量类型声明处理

> 变量声明 VarDecl → BType`↑t` VarDef`↓t ` { ',' VarDef`↓t` } ';'
>
> 变量定义 VarDef`↓t` → Ident`↑n` { '[' ConstExp ']' } | Ident { '[' ConstExp ']' } '=' InitVal`↑c` `@insertSymbolList ↓t↓n↓c` 

**@insertSymbolList**: 

1. 检查所声明的类型t和常量初值类型是否一致，如果不一致，产生错误信息。**在代码生成作业一，源程序本身没有错误，所以先不考虑此条功能**
2. 若变量初值存在，把名字n，类型t 和常量表达式的值c 填入符号表中



**？？？**表达式的值c存入符号表的那部分位置，或者存入运行栈的那部分位置。



#### 表达式语句的语义分析

分析表达式的主要目的是生成能够正确计算表达式值的代码。实现目的的主要策略是，首先将操作数装在带操作数栈顶，然后执行表达式做指定的操作，并将结果保留在操作数栈中。

**改写成属性翻译文法**

> 条件表达式 Cond → LOrExp
>
> 逻辑或表达式 LOrExp → LAndExp { '||' LAndExp `@ORR`} 
>
> 逻辑与表达式 LAndExp → EqExp { '&&' EqExp `@AND`} 
>
> 相等性表达式 EqExp → RelExp { ('==' | '!=') RelExp  `@EQL`  `@NEQ` }
>
> 关系表达式 RelExp → AddExp { ('<' | '>' | '<=' | '>=') AddExp `@LSS`  `@GRT`  `@LER`  `@GEQ`}
>
> 加减表达式 AddExp → MulExp { ('+' | '−') MulExp `@ADD`  `@SUB` }
>
> 乘除模表达式 MulExp → UnaryExp { ('*' | '/' | '%') UnaryExp`@MUL` `DIV` `MOD` }
>
> - [ ] ⼀元表达式 UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp`↑UOpType` UnaryExp `@ADDorSUBorNOT` 
>
> 单⽬运算符 UnaryOp`↑UOpType` → '+' `↑UOpType`| '−' `↑UOpType`| '!' `↑UOpType`  注：'!'仅出现在条件表达式中盖 
>
> 基本表达式 PrimaryExp → '(' Exp ')' | LVal | Number`↑i` `@RunStackPush ↓i`
>
> 左值表达式 LVal → Ident `↑n`  {'[' Exp ']'} `@SymTabFind ↓n↑j`  `@RunStackPush ↓j`
>
> 
>
> 常量表达式 ConstExp → AddExp 注：使⽤的Ident 必须是常量 
>
> 表达式 Exp → AddExp



**各属性和动作符号的功能**



#### 赋值语句

赋值语句的语义，计算赋值号右部表达式的值，然后将他赋给赋值号左边的变量

**改写成属性翻译文法**

> Stmt → LVal '=' Exp ';'`@STO`
>
> 左值表达式 LVal → Ident `↑n`  {'[' Exp ']'} `@SymTabFind ↓n↑j`  `@RunStackPush ↓j`
>
> 表达式 Exp → AddExp
>
> 加减表达式 AddExp → MulExp { ('+' | '−') MulExp `@ADD`  `@SUB` }
>
> 乘除模表达式 MulExp → UnaryExp { ('*' | '/' | '%') UnaryExp`@MUL` `DIV` `MOD` }
>
> - [ ] ⼀元表达式 UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp`↑UOpType` UnaryExp `@ADDorSUBorNOT` 
>
> 单⽬运算符 UnaryOp`↑UOpType` → '+' `↑UOpType`| '−' `↑UOpType`| '!' `↑UOpType`  注：'!'仅出现在条件表达式中盖 
>
> 基本表达式 PrimaryExp → '(' Exp ')' | LVal | Number`↑i` `@RunStackPush ↓i`
>
> 左值表达式 LVal → Ident `↑n`  {'[' Exp ']'} `@SymTabFind ↓n↑j`  `@RunStackPush ↓j`



若赋值变量是一个数组元素，编译程序先要生成调用计算数组元素地址的子程序，然后生成`LOD`指令,将该地址加载到操作数栈栈顶



#### 控制语句

包括If语句，循环语句，*多分支语句（课下未涉及）*

##### if语句

对于if结构的处理主要是生成多条转移指令，以实现该结构所规定的控制流。

**改写成属性翻译文法**

> 'if' '( Cond ')' `@JPC↑y`Stmt `@labprod↓y`(ε| 'else' `@JMP↑z` `@labprod↓y` Stmt `@labprod↓z`) // 1.有else 2.⽆else 

<img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211117195327168.png" alt="image-20211117195327168" style="zoom: 50%;" />

处理Cond所生成的目标代码是计算该条件表达式的值，并将其结果置于运行栈栈顶。如果栈顶值为假，则采用`JPC`指令控制跳转。

**动作程序实现**



##### While语句

需要设置两个标号，lab1作为返回循环开头的标号，lab2作为循环结束跳转的标号

**改写成属性翻译文法**

> Stmt → 'while'  `@labgen↑r` '(' Cond ')' `@falsebranch↑f` Stmt `@retbranch↓r` `@labemit↓f`
>
> Stmt → 'break' ';' | 'continue' ';' 

**动作程序功能及其实现**



#### 函数调用和返回语句

本实验函数调用时，形参和实参之间的数据传递方式通过传值形式实现。调用函数的目标程序段，把实参的值计算出来，并存放在运行栈中。被调用段将实参的值传进形参的数据单元中。

##### 函数声明

##### 函数调用



#### 输入输出语句

##### 1.输入语句

**属性文法改写**

> Stmt → LVal = `'getint' ` `'('` ` ')' ` `';'` `@getint==RED ↑i ` `@RunStackPush ↓i` `@STO将栈顶值装入次栈顶`
>
> 左值表达式 LVal → Ident `↑n`  {'[' Exp ']'} `@SymTabFind ↓n↑j`  `@RunStackPush ↓j`

```
int getint(){
	int n; 
	scanf("%d",&n); 
	return n; 
}
```



##### 2.输出语句





#### 运行栈的实现

`RunStack`





### PCode解释执行



#### PCode指令表

![image-20211117205935777](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211117205935777.png)

![image-20211117210025033](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211117210025033.png)

![image-20211117210052346](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211117210052346.png)