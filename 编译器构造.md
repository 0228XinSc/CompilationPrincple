# 编译器构造

为一个具体语言编写一个编译器是一个较为复杂的任务，需要耗费较多的时间，查阅学习各种书籍，整体完成后的代码量应该是不容小觑的。仅仅是完成一个简单的词法分析就需要400行代码完成，且还不是最终版本。

以下给出编译程序的基本模型，希望能够依据以下模型分模块完成代码的编写。



## 语法分析文档



#### 对于上次词法分析代码的进一步优化

```
#define IDENFR 1
#define INTCON 2
#define STRCON 3
#define MAINTK 4
#define CONSTTK 5
#define INTTK 6
#define BREAKTK 7
#define CONTINUETK 8
#define IFTK 9
#define ELSETK 10
#define NOT 11
#define AND 12
#define OR 13
#define WHILETK 14
#define GETINTTK 15
#define PRINTFTK 16
#define RETURNTK 17
#define PLUS 18
#define MINU 19
#define VOIDTK 20
#define MULT 21
#define DIV 22
#define MOD 23
#define LSS 24
#define LEQ 25
#define GRE 26
#define GEQ 27
#define EQL 28
#define NEQ 29
#define ASSIGN 30
#define SEMICN 31
#define COMMA 32
#define LPARENT 33
#define RPARENT 34
#define LBRACK 35
#define RBRACK 36
#define LBRACE 37
#define RBRACE 38
#define ERROR 39
#define NOTES 40
```

## 错误处理

​		在程序编写完成后，每一个程序员都无法保证自己的程序完全符合语法、语义规则和其他的一些规定。这些错误如果没有编译器给出的相关提示，想要修改就需要耗费相当多的时间，拖慢编程的效率和准确性。所以编译器对程序的错误处理就显得至关重要。

#### 程序设计要求

​		根据给定文法设计相关的错误处理程序，能够**将违反常见语法和语义规则的错误反馈给编码者**，同时能进行**错误局部化处理**。反馈方式为当出现错误后，输出相应的错误类别码和错误出现位置所在的行号。不过在本次实验之后，错误处理最好能够详细的说明错误信息，能够帮助完善编译器设计与开发。

​		对于语法错误，即违反文法定义的编码方式。

​		对于语义错误，可详见文法定义与相关说明的语义约束部分，还包含超越具体计算机系统的限制。如顶层变量/常量声明，函数定义时不能重复定义同名标识符，此时还需要**符号表管理**来帮助判断是否重名。

​		对于错误局部化处理，解释是当程序发现错误后，尽可能将错误限制在一个局部的范围内，避免错误扩散和影响程序其它部分的分析和检查。

​	**错误类别码**：

​		用做错误类型的识别，以及输出。

​	![image-20211019162028729](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211019162028729.png)

#### 符号表管理

​		符号表适用于保存每个标识符及其属性信息的数据结构，在符号表的表型中登录标识符的属性。使用符号表能快速地找到每个标识符的表项并能快速存储和检索表项记录的数据信息。

​		在多变扫描的编译程序中，在词法分析阶段就将标识符填入符号表，标识符的其他属性则在语义分析和代码生成阶段填入。

##### 符号表的构建方式

​		符号表的存取操作可能会花去编译期间很多的处理器时间，所以需要合理的选择符号表的组织形式，选择高效的填表查表方式，这样才能提高编译程序的工作效率。

##### 符号表典型结构

| token/Name | 标识符类型 | 数据类型 | 行号 |
| ---------- | ---------- | -------- | ---- |
|            | 函数       | int      |      |
|            | 常量       | array1   |      |
|            | 变量       | array2   |      |
|            | 形参       | void     |      |

对于一些特殊的类型需要考虑更多的信息：

1. 数组

   维数、上下界值

2. 函数

   **形参个数**，形参类型，**实参个数**，实参类型，所在层次，函数返回值。

其中**输出行号**，可以通过`SymbolListLine`对应位置获得。不需要通过符号表获得。但也可以将对应行号存入`SymbolTable`结构中

##### 符号表组织形式

​	采用栈式符号表进行组织，同时利用分程序索引表保存程序层次。

##### 符号表典型操作

1. 填表

   找到与标识符有关的文法，对标识符的信息进行分析，将新纪录推入栈顶单元即可。要考虑标识符在同一分程序同名情况。

   标识符Name，存放在TokenList string数组

2. 查表

   需要将符号表填表和查表操作进一步独立

   什么情况下查表：

   ​		**声明部分**时：查询该标识符在所在程序单元`从栈式符号表栈顶到分程序索引表栈顶对应的栈式符号表位置`中是否存在同名的标识符，查表函数的形参为`token字符串`，函数类型`int`返回`同名标识符在栈式符号表的下标`或者`-1`。

   ​		**调用部分**：查询所在程序单元的符号表中是否存在同名的标识符，若存在，说明该标识符已声明；若不存在，继续向外层程序单元进行查询，直至到最外层单元仍未出现同名标识符时，说明该标识符未声明。

   ​		分程序的开始：执行定位操作

   ​		分程序的结束：执行重定位操作

3. 定位

   分程序索引表的顶端填入新的分程序索引项。（即分程序头一个标识符在符号表的位置）

   定位时机在判断当前标识符是一个函数名时

   不能只考虑函数的定位和重定位，在while if else 等含有block的语句都能声明新的变量。可是while if else 都没有变量名 *如何记录变量名在栈中的位置*，while if else 都是语句在stmt 中的block 前进行定位，在block后进行重定位，即可

4. 重定位

   清除刚刚被编译完的分程序在栈式符号表中的所有记录。

   考虑分程序符号表为空情况

   //重定位时机在block `}`结束后,**错误**

   应该是{},之间一一对每次大括号都要定位，但是

   在函数结束时重定位，应该是funcdef }

   对于在main函数之前的函数的重定位情况

##### 哪些文法需要填表

```
/*声明*/
ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal
VarDef → Ident { '[' ConstExp ']' }| Ident { '[' ConstExp ']' } '=' InitVal
FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
/*调用*/
LVal → Ident {'[' Exp ']'}
UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')'
```



##### 疑惑

- 形参是多维数组时， int [] [`Constexp`] 的`Constexp`会不会出现ident 。

  

#### 错误处理实现

在用递归下降分析法进行语法分析是，一旦检查出错误就将错误性质送给变量cx（行号，错误类型，），然后转出错处理,根据cx输出错误的类型和对应的行号，并且还能保证能够运行之后的程序。

对以上错误类型进行处理。

首先将错误分类成语法错误和语义错误。语法错误包含以下几项

##### 语法错误

![image-20211026182703756](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211026182703756.png)

###### 缺少分号

同下

###### 缺少右小括号

不仅仅要输出出错的位置，还要对错误进行改正，防止影响之后的程序错误判断。比如if(`)`缺少，会导致跳出if else整体判断，if之后若紧跟else，那么无法对else进行分析，导致死循环。要进行错误修正。修正后返回语句的开始进行判断。

在返回语句开始的同时需要注意语句中是否会有函数的声明，即是否会造成标识符入符号表栈，如果有，需要将标识符弹出。

突然想到好像不用错误修正，直接在error后继续本应该的判断就行。

###### 缺少右中括号

实现以上三中缺少对应右部匹配符号的错误处理，当前`SymbolList[CurSymPos]`类别码已经找不到正确的引号小括号中括号。

###### 非法符号实现

出现位置，在`printf`语句的字符串中。`ForMatString` 字符串在词法分析中就已经被放入token中。可以在语法分析`ForMatString`函数中新建一个局部变量`ForMatStringFlag`局部变量对当前token进行判断，是否存在非法符号。

非法符号定义为：32，33，40-126之外的ASCII字符，若出现\则后边必须跟n

报错行号为`STRON`类别码对应的行号，即`SymbolListLine[CurSymPos]`

错误处理结束后，进行下一个字符的判断（当前是`strcon`如果不读下一个，那么跳出`formatstring`函数后，之后的递归下降判断无法通过，会导致死循环）

##### 语义错误

###### 名字重定义

![image-20211025215347372](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025215347372.png)

出现在变量常量函数函数参数的声明中，只需在插入符号函数中进行判断即可

？？？名字重定义后，不填入符号表，输出<ident>行号，也就是当前类别码位置地行号，还要进行什么操作，

###### 未定义的名字

![image-20211025232437555](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025232437555.png)

调用部分，符号表中是否有过声明，即是栈式符号表中是否有对应的标识符。

###### 函数参数个数不匹配

![image-20211025234313605](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025234313605.png)

需要对符号表进行增加，记录函数参数的个数，在调用的时候进行判断。新建一个结构体保存函数参数的个数和类型。在函数参数声明 和函数参数调用时进行调用。

声明时，在进入形参函数之前定义一个`PramNum`，将`int &PramNum `作为形参函数的形参，用来返回改变后的`ParmNum`值。

`UnaryExp`调用，首先不会知道标识符的数据类型，只有在栈中找到标识符的声明之后，获得标识符的数据类型。如果是函数标识符类型，获得其函数的形参个数`n`和声明标识符在符号表中的位置，将这些作为实参表的形参，在实参表函数中进行判断。对其后的n个标识符`即形参`和当前标识符之后的的`n`。对而标识符函数调用时，函数参数和函数个数在完成函数实参表时才能够获取到。

###### 函数参数类型不匹配

![image-20211027013334208](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211027013334208.png)

不应该是对函数名之后n个变量进行判断，符号表不能这样存储形参，因为在定义的函数结束后，除了函数名保存在栈符号表中外，其他局部变量全部弹出。在之后调用函数时，其形参已经不在符号表中。在其他信息结构体中添加新的数组，用来存储各个形参类型。在函数名对应位置的补充信息中的形参表收集从FuncFParams 获得的

令FuncFParams 改变ExtraSymbol，令FuncFParam返回DataType。

###### 不能改变常量的值

从Lval返回变量类型，对之后的等号进行判断

### DeBug

1. 语法分析中将else 无大括号 跟的IF（）中的if（）当作函数调用

   修改语法分析中的Unary 加特判ident 不能是 if



![image-20211027010222434](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211027010222434.png)

![image-20211027012248798](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211027012248798.png)

2.![image-20211027181641049](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211027181641049.png)

未定义名字出问题，重定位位置有问题。定位在func，while，if， else

重定位直接在block尾部。

tle 因为判断函数类型是直接在FuncRParams中return了，导致语法分析无法正常结束。

3.![image-20211027190559640](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211027190559640.png)

d有问题

注意函数在没有形参时，给形参个数置零

m有问题，没有考虑while嵌套的情况。

```
while(){
	while(){
		
	}
	break;//此时会输出m错误
}
{
	break;
	continue;
}
/*不是在Block就置*/
```

c 输出行号为变量位置的行号CurPos-1；

b名字重定义问题。

单独一个{}重定位问题

函数调用时，参数是void函数问题。