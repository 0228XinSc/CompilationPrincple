# 编译器

为一个具体语言编写一个编译器是一个较为复杂的任务，需要耗费较多的时间，查阅学习各种书籍，整体完成后的代码量应该是不容小觑的。仅仅是完成一个简单的词法分析就需要400行代码完成，且还不是最终版本。

## 编译器构造

下图给出编译器的构造方式，分成两个部分。

**分析部分（前端）：**由词法分析、语法分析、语义分析所构成的分析部分的作用是对源程序文本进行分析，最后生成中间代码。词法分析将源程序的文法分析出文法类别码提供给语法分析程序，语法分析将类别码进一步组合成语法成分信息，如<CompUnit>。语义分析对语法成分进行进一步的分析，识别出具体含义并且生成中间代码。

**综合部分（后端）：**通过代码生成和代码优化生成目标程序。代码生成部分将源程序的中间形式转换为汇编语言或者机器语言。进行代码优化的主要目的是要获得更高效的目标程序，在确保源代码功能不变的前提下，使目标代码更简短，减少存储空间和运行时间。

![image-20211109213828948](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109213828948.png)

### 分析过程中重要的定义

1. 类别码

   ![image-20211109221016726](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109221016726.png)

2. 文法

   ![image-20211109221241189](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109221241189.png)

   ![image-20211109221512520](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109221512520.png)

   ![image-20211109221542802](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211109221542802.png)

## 词法分析文档

**主要功能**

​	词法分析逐个读取源文件的字符，根据当前字符对类别码进行识别。同时将字符组合成单词进行输出。还要对数字常数完成数字字符到十进制字符的转换。同时删去空格字符和注释。

**词法分析实现**

采用词法分析单独作为一遍实现，将分析出的类别码放到一个`int SymbolList[100000]`数组中记录,以供语法分析使用。

利用`extern map<int,string> MapSymbol`对类别码和对应编号一一对应，string语句既是最后输出语句。

**类别码对应编号**

```
#define IDENFR 1
#define INTCON 2
#define STRCON 3
#define MAINTK 4
#define CONSTTK 5
#define INTTK 6
#define BREAKTK 7
#define CONTINUETK 8
#define IFTK 9
#define ELSETK 10
#define NOT 11
#define AND 12
#define OR 13
#define WHILETK 14
#define GETINTTK 15
#define PRINTFTK 16
#define RETURNTK 17
#define PLUS 18
#define MINU 19
#define VOIDTK 20
#define MULT 21
#define DIV 22
#define MOD 23
#define LSS 24
#define LEQ 25
#define GRE 26
#define GEQ 27
#define EQL 28
#define NEQ 29
#define ASSIGN 30
#define SEMICN 31
#define COMMA 32
#define LPARENT 33
#define RPARENT 34
#define LBRACK 35
#define RBRACK 36
#define LBRACE 37
#define RBRACE 38
#define ERROR 39
#define NOTES 40
```

**通过画出文法状态图，知道各类型单词的判断过程。**

1. 保留字（字母构成）和标识符（由字母或`_`开始，可以包含数字字母或者 `_` ）过程

   由字母或者_开始，向后继续查找字母或者数字或者` _`,同时将字符组合起来。通过对`token`字符串和保留字判断，设置对应`symbol`类别码，若不是保留字，即是标识符`IDENFR`。

2. 数字过程

   由数字开始，继续查找数字，整合成数字字符串，转化成数字。

3. 注释过程

   `/* */`注释

   嵌套在判断除号过程中，初始实现思想是当遇到`/*`注释开始，遇到`*/`注释结束。所以需要每次判断当前字符位置/和上一个字符位置*。

   不过遇到这种情况

   ```
    /*/*
        * /testfile created with ``heart'' by 19373384
        *
       /
       */
   ```

   其中/*/也会导致注释结束，所以再次多向前读取一个字符进行判断

   `//`注释

   判断注释到遇到`\n`结束

4. 其他字符

   其他字符直接设置对应的类别码就行。

**重要约束**

​		在进入各类型识别函数之前，获得新的字符，在结束识别函数时，对当前字符进行更新。

## 语法分析文档

​		语法分析是编译过程的核心部分。语法分析的任务是按照文法，从源程序类别码中识别出个类语法程序，同时进行语法检查，为语义和生成代码做准备。

​		本次采用递归下降分析法，对文法的每个非终结符都编写对应的子程序，以完成非终结符号所对应的语法成分和识别任务。某个非终结符号的语法分析子程序的功能是，用该非终结符的规则的右部符号串去匹配输入符号串。

​		整个语法分析从`CompUnit()`函数进入，然后对之后的类别码进行分析。进入一个子程序需要判断FIRST集合，甚至有些语法成分分析的进入，需要预读很多位类别码才能判断。对于BFS中{}一般通过while实现，[]通过if进行实现。

​		对于具有左递归的文法需要利用相应规则进行改写。

**左递归文法的改写**	

```
AddExp → MulExp | AddExp ('+' | '−') MulExp
-》
AddExp → MulExp { ('+' | '−') MulExp }

RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
-》
RelExp → RelExp { ('<' | '>' | '<=' | '>=') RelExp }

EqExp → RelExp | EqExp ('==' | '!=') RelExp
-》
EqExp → EqExp { ('==' | '!=') EqExp}

LAndExp → EqExp | LAndExp '&&' EqExp
-》
LAndExp → EqExp { '&&' EqExp }

LOrExp → LAndExp | LOrExp '||' LAndExp
-》
LOrExp → LAndExp { '||' LAndExp }
```



**重要约束**

虽然有些语法成分不需要输出，但不要擅自省略其对应的子程序函数。否则对整体文法的正确性会有很大影响。

当调用某个分析子程序时，他分析的第一符号`SymbolList[CurSymPos]`；在分析子程序返回报告成功前，将CurSymPos的位置+1，即获得下一个类别码。

**代码修改**

将省略的语法成分`BType` 补全

## 错误处理

​		在程序编写完成后，每一个程序员都无法保证自己的程序完全符合语法、语义规则和其他的一些规定。这些错误如果没有编译器给出的相关提示，想要修改就需要耗费相当多的时间，拖慢编程的效率和准确性。所以编译器对程序的错误处理就显得至关重要。

#### 程序设计要求

​		根据给定文法设计相关的错误处理程序，能够**将违反常见语法和语义规则的错误反馈给编码者**，同时能进行**错误局部化处理**。反馈方式为当出现错误后，输出相应的错误类别码和错误出现位置所在的行号。不过在本次实验之后，错误处理最好能够详细的说明错误信息，能够帮助完善编译器设计与开发。

​		对于语法错误，即违反文法定义的编码方式。

​		对于语义错误，可详见文法定义与相关说明的语义约束部分，还包含超越具体计算机系统的限制。如顶层变量/常量声明，函数定义时不能重复定义同名标识符，此时还需要**符号表管理**来帮助判断是否重名。

​		对于错误局部化处理，解释是当程序发现错误后，尽可能将错误限制在一个局部的范围内，避免错误扩散和影响程序其它部分的分析和检查。

​	**错误类别码**：

​		用做错误类型的识别，以及输出。

​	<img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211019162028729.png" alt="image-20211019162028729" style="zoom: 80%;" />

>

##### 哪些文法需要填表

```
/*声明*/
ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal
VarDef → Ident { '[' ConstExp ']' }| Ident { '[' ConstExp ']' } '=' InitVal
FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
/*调用*/
LVal → Ident {'[' Exp ']'}
UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')'
```



> ##### 疑惑
>
> - 形参是多维数组时， int [] [`Constexp`] 的`Constexp`会不会出现ident 。
>
>   
>

#### 错误处理实现

在用递归下降分析法进行语法分析是，一旦检查出错误就将错误性质送给变量cx（行号，错误类型），然后转出错处理,根据cx输出错误的类型和对应的行号，并且还能保证能够运行之后的程序。

对以上错误类型进行处理。

首先将错误分类成语法错误和语义错误。语法错误包含以下几项

##### 语法错误

![image-20211026182703756](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211026182703756.png)

###### 缺少分号

同下

###### 缺少右小括号

不仅仅要输出出错的位置，还要对错误进行改正，防止影响之后的程序错误判断。比如if(`)`缺少，会导致跳出if else整体判断，if之后若紧跟else，那么无法对else进行分析，导致死循环。要进行错误修正。修正后返回语句的开始进行判断。

在返回语句开始的同时需要注意语句中是否会有函数的声明，即是否会造成标识符入符号表栈，如果有，需要将标识符弹出。

突然想到好像不用错误修正，直接在error后继续本应该的判断就行。

###### 缺少右中括号

实现以上三中缺少对应右部匹配符号的错误处理，当前`SymbolList[CurSymPos]`类别码已经找不到正确的引号小括号中括号。

###### 非法符号实现

出现位置，在`printf`语句的字符串中。`ForMatString` 字符串在词法分析中就已经被放入token中。可以在语法分析`ForMatString`函数中新建一个局部变量`ForMatStringFlag`局部变量对当前token进行判断，是否存在非法符号。

非法符号定义为：32，33，40-126之外的ASCII字符，若出现\则后边必须跟n

报错行号为`STRON`类别码对应的行号，即`SymbolListLine[CurSymPos]`

错误处理结束后，进行下一个字符的判断（当前是`strcon`如果不读下一个，那么跳出`formatstring`函数后，之后的递归下降判断无法通过，会导致死循环）

##### 语义错误

###### 名字重定义

![image-20211025215347372](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025215347372.png)

出现在变量常量函数函数参数的声明中，只需在插入符号函数中进行判断即可

> ？？？名字重定义后，不填入符号表，输出<ident>行号，也就是当前类别码位置地行号，还要进行什么操作，

###### 未定义的名字

![image-20211025232437555](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025232437555.png)

调用部分，符号表中是否有过声明，即是栈式符号表中是否有对应的标识符。

###### 函数参数个数不匹配

![image-20211025234313605](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211025234313605.png)

需要对符号表进行增加，记录函数参数的个数，在调用的时候进行判断。新建一个结构体保存函数参数的个数和类型。在函数参数声明 和函数参数调用时进行调用。

声明时，在进入形参函数之前定义一个`PramNum`，将`int &PramNum `作为形参函数的形参，用来返回改变后的`ParmNum`值。

`UnaryExp`调用，首先不会知道标识符的数据类型，只有在栈中找到标识符的声明之后，获得标识符的数据类型。如果是函数标识符类型，获得其函数的形参个数`n`和声明标识符在符号表中的位置，将这些作为实参表的形参，在实参表函数中进行判断。对其后的n个标识符`即形参`和当前标识符之后的的`n`。对而标识符函数调用时，函数参数和函数个数在完成函数实参表时才能够获取到。

###### 函数参数类型不匹配

![image-20211027013334208](C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211027013334208.png)

不应该是对函数名之后n个变量进行判断，符号表不能这样存储形参，因为在定义的函数结束后，除了函数名保存在栈符号表中外，其他局部变量全部弹出。在之后调用函数时，其形参已经不在符号表中。在其他信息结构体中添加新的数组，用来存储各个形参类型。在函数名对应位置的补充信息中的形参表收集从FuncFParams 获得的

令FuncFParams 改变ExtraSymbol，令FuncFParam返回DataType。

###### 不能改变常量的值

从Lval返回变量类型，对之后的等号进行判断

## 符号表管理

​		符号表适用于保存每个标识符及其属性信息的数据结构，在符号表的表型中登录标识符的属性。使用符号表能快速地找到每个标识符的表项并能快速存储和检索表项记录的数据信息。

​		在多变扫描的编译程序中，在词法分析阶段就将标识符填入符号表，标识符的其他属性则在语义分析和代码生成阶段填入。

### 符号表的构建方式

​		符号表的存取操作可能会花去编译期间很多的处理器时间，所以需要合理的选择符号表的组织形式，选择高效的填表查表方式，这样才能提高编译程序的工作效率。

#### 符号表结构

**1. 主要部分**

​	`NameIndex`   变量名在`TokenList所有变量名数组`的位置

​	`IdentTypeId` 标识符类型

​	`DataTypeId `    数据类型

​	`LineNumIndex `   标识符在记录行号数组中的下标

​	`FuncInformation`指向其他函数补充信息的函数信息表指针

​	指向数组类型的数组向量表指针

​	`ObjectAddress`  目标地址，对于变量（包括形参名），应填入该变量（或形参）在运行栈S中分配存储单元的相对地址；对于函数名，应填入它们相应目标代码的入口地址。 

| token/Name | 标识符类型      | 数据类型        | 行号 | 补充符号表指针 |
| ---------- | --------------- | --------------- | ---- | -------------- |
|            | 函数 Func ---1  | int           0 |      |                |
|            | 常量 Const --2  | array1    1     |      |                |
|            | 变量 Var -----3 | array2    2     |      |                |
|            | 形参 Parm --4   | void        3   |      |                |

```c++
struct MainSymbolTable{
    MainSymbolTable(
            int _NameIndex,
            int _IdentTypeId,
            int _DataTypeId,
            int _LineNumIndex,
            FuncInformationTab* _FunInformation,
            int _IntValue
            ) :
            NameIndex(_NameIndex),
            IdentTypeId(_IdentTypeId),
            DataTypeId(_DataTypeId),
            LineNumIndex(_LineNumIndex),
            FuncInformation(_FunInformation),
            IntValue(_IntValue){}
    int NameIndex;//传TokenList 的i位置
    int IdentTypeId;
    int DataTypeId;
    int LineNumIndex;//标识符在记录行号数组中的下标
    FuncInformationTab* FuncInformation;
    int IntValue;//对此部分有疑问，到底是指向值的地址，还是直接存值（直接存值在类型是函数时，应该存成-1？0？最小值）
	//应该存目标地址，1可以在不是常量变量的时候，扎入符号表示置NULL
    //2.在进行赋值操作时，STO指令是将栈顶的值赋给次栈顶，若为值传递，无法结果值赋给符号表中的目标值。
};
```

**2.函数声明信息：**

​	记录形参个数和形参的类型，用于错误处理函数形参和实参之间的匹配

```c++
/*函数信息表结构*/
typedef struct FuncInformationTable{
    int FParmNum;
    int FParmList[500];
} FuncInformationTab;
```

**3.int型存值：**

```c++
/*整型数值表*/
typedef struct IntInformationTable{
    int IntValue;
} IntInformationTab;
```

**4.数组向量表：**



对于一些特殊的类型需要考虑更多的信息：

1. **数组**

   维数、上下界值

2. **函数**

   **形参个数**，形参类型，**实参个数**，实参类型，所在层次，函数返回值。

#### 符号表组织形式

​	采用栈式符号表进行组织，同时利用分程序索引表保存程序层次。

### 符号表典型操作

1. **填表**

   找到与标识符有关的文法，对标识符的信息进行分析，将新纪录推入栈顶单元即可。要考虑标识符在同一分程序同名情况。

   标识符Name，存放在TokenList string数组

   分不同情况进行填表

   1. 标识符是声明时填表

      **存在重复声明错误**，需要先对

      1. 常量， 先不考虑常量放到

   2. 标识符是调用时填表

2. **查表**

   需要将符号表填表和查表操作进一步独立

   什么情况下查表：

   ​		**声明部分**时：查询该标识符在所在程序单元`从栈式符号表栈顶到分程序索引表栈顶对应的栈式符号表位置`中是否存在同名的标识符，查表函数的形参为`token字符串`，函数类型`int`返回`同名标识符在栈式符号表的下标`或者`-1`。

   ​		**调用部分**：查询所在程序单元的符号表中是否存在同名的标识符，若存在，说明该标识符已声明；若不存在，继续向外层程序单元进行查询，直至到最外层单元仍未出现同名标识符时，说明该标识符未声明。

   ​		分程序的开始：执行定位操作

   ​		分程序的结束：执行重定位操作

3. **定位**

   分程序索引表的顶端填入新的分程序索引项。（即分程序头一个标识符在符号表的位置）

   定位时机在判断当前标识符是一个函数名时

   > 不能只考虑函数的定位和重定位，在while if else 等含有block的语句都能声明新的变量。可是while if else 都没有变量名 *如何记录变量名在栈中的位置*，while if else 都是语句在stmt 中的block 前进行定位，在block后进行重定位，即可

4. **重定位**

   清除刚刚被编译完的分程序在栈式符号表中的所有记录。

   考虑分程序符号表为空情况

   > //重定位时机在block `}`结束后,**错误**

>应该是{},之间一一对每次大括号都要定位，但是
>
>在函数结束时重定位，应该是funcdef }
>
>对于在main函数之前的函数的重定位情况

### 其他表格

#### 分程序索引表

数据结构：动态整型数组

#### 数组向量表

#### PCode目标代码表

数据结构为：

```c++
struct RunStack{
	int f;//对应pcode操作指令的操作码
	int x;//变量所在分程序层次
	int* y;//变量值对应的存储相对地址
};
extern vector<RunStack> RunStack;
```



## 代码生成

实验要求：请在词法分析、语法分析及错误处理作业的基础上，为编译器实现语义分析、代码生成功能。本次实验设计以生成PCODE作为目标代码的编译器。

特别说明：本次作业是为了让同学们尽快实现一个完整的编译器，测试程序中仅涉及**常量声明、变量声明、读语句、写语句、赋值语句，加减乘除模除等运算语句、函数定义及调用语句**。在之前完成的语法分析的基础上，对文法进行修改，添加相应的语义动作子程序，在进行语法分析同时实现语义动作，生成与源程序语义对应的PCode指令序列，存入PCode代码表中。若想完成编译器的完美运行，仅生成中间代码是不够的，还需要对Pcode进行解释执行，即从PCode表中逐个取出指令，对相应数据（常量，变量，函数）进行存入，运算，调用等操作，获得代码执行最终结果。

### 语义分析生成PCode及解释执行

首先，将文法修改成对应的属性翻译文法，将每个子程序添加相应的继承属性和综合属性、语义动作程序**（在语义分析阶段**`Semantic_analysis.cpp`**中实现）**，以生成Pcode指令序列。在执行部分构造运行栈、数据栈。

#### 声明语句的语义分析

属性命名 Attr_+Name

##### 常量类型声明处理

​	需要将常量当作全局名处理，即加入符号表时只插入层次最高的表顶。

> 常量声明 ConstDecl → 'const'`↑Attr_IdnetType` BType`↑Attr_DataType` ConstDef`↓Attr_DataType ↓Attr_IdnetType `  { ',' ConstDef`↓Attr_DataType ↓Attr_IdnetType`  } ';'
>
> 基本类型 BType`↑Attr_DataType` → 'int'`↑Attr_DataType`  
>
> 常数定义 ConstDef`↓Attr_DataType ↓Attr_IdnetType` → Ident`↑Attr_Name` `@pushIntDataTable` { '[' ConstExp ']' }  `@RunStackPush ↓j` ‘=' ConstInitVal `@Sem_sto↑Attr_CValue` `@insertSymbolList↓Attr_DataType↓Attr_Name↓Attr_CValue`

1. **属性**

   `Attr_DataType`:保存数据类型

   `Attr_Name`:保存常量名所在类别码数组下标

   `Attr_CInitValue`:保存表达式计算的最终结果值

2. **语义动作**

   **@insertSymbolList**: 把名字n，类型t 和常量表达式的值c 填入符号表中

   ```
   此程序在Table.cpp实现，插入符号表位置
   ```

   ConsInitVal结束后，应该会将结果置于栈顶单元。先把变量的目标地址载入栈顶，再等待COnstInitVal结束后，STO将栈顶内容存入次栈顶的目标地址中。
   
   **@pushIntDataTable**：把每一个常量在声明时，push到数据存储区。	

##### 变量类型声明处理

> 变量声明 VarDecl → `↑Attr_IdnetType` BType `↑Attr_DataType`  VarDef`↓Attr_DataType`  { ',' VarDef`↓Attr_DataType` } ';'
>
> 变量定义 VarDef`↓Attr_DataType` → Ident`↑Attr_Index` { '[' ConstExp ']' } | Ident `↑Attr_Index`  { '[' ConstExp ']' } `@insertSymbolList ↓Attr_DataType↓Attr_Index `  '='  `@RunStackPush ↓j` InitVal `@Sem_sto` 

**@insertSymbolList**: 

1. 检查所声明的类型t和常量初值类型是否一致，如果不一致，产生错误信息。**在代码生成作业一，源程序本身没有错误，所以先不考虑此条功能**
2. 若变量初值存在，把名字n，类型t 和常量表达式的值c 填入符号表中

**@RunStackPush**

1. 生成一条LOD指令
2. 将j目标地址压入运行栈中，必须是知道当前变量需要赋值的时候才LOD，即

[^？？？]: 表达式的值c存入符号表的那部分位置，或者存入运行栈的那部分位置。
[^answer]: 表达式值存入运行栈栈顶



#### 表达式语句的语义分析

分析表达式的主要目的是生成能够正确计算表达式值的代码。实现目的的主要策略是，首先将操作数装在带操作数栈顶，然后执行表达式做指定的操作，并将结果保留在操作数栈中。

**改写成属性翻译文法**

> 条件表达式 Cond → LOrExp
>
> 逻辑或表达式 LOrExp → LAndExp { '||' LAndExp `@ORR`} 
>
> 逻辑与表达式 LAndExp → EqExp { '&&' EqExp `@AND`} 
>
> 相等性表达式 EqExp → RelExp { ('==' | '!=') RelExp  `@EQL`  `@NEQ` }
>
> 关系表达式 RelExp → AddExp { ('<' | '>' | '<=' | '>=') AddExp `@LSS`  `@GRT`  `@LER`  `@GEQ`}
>
> 加减表达式 AddExp → MulExp { ('+' | '−') MulExp `@ADD`  `@SUB` }
>
> 乘除模表达式 MulExp → UnaryExp { ('*' | '/' | '%') UnaryExp`@MUL` `DIV` `MOD` }
>
> - [ ] ⼀元表达式 UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp`↑UOpType` UnaryExp `@ADDorSUBorNOT` 
>
> 单⽬运算符 UnaryOp`↑UOpType` → '+' `↑UOpType`| '−' `↑UOpType`| '!' `↑UOpType`  注：'!'仅出现在条件表达式中盖 
>
> 基本表达式 PrimaryExp → '(' Exp ')' | LVal | Number`↑Attr_NumValue` `@RunStackPush ↓Attr_NumValueAddr`
>
> 左值表达式 LVal → Ident `↑Attr_Index`  {'[' Exp ']'} `@SymTabFind ↓Attr_Index↑Attr_Index`  `@RunStackPush ↓Attr_Index`
>
> 
>
> 常量表达式 ConstExp → AddExp 注：使⽤的Ident 必须是常量 
>
> 表达式 Exp → AddExp
>
> 



#### 赋值语句

赋值语句的语义，计算赋值号右部表达式的值，然后将他赋给赋值号左边的变量

**改写成属性翻译文法**

> 1.Stmt → LVal '=' Exp ';'`@STO`
>
> 2.LVal = 'getint''('')'';'
>
> 左值表达式 LVal → Ident `↑n`  {'[' Exp ']'} `@SymTabFind ↓n↑j`  `@RunStackPush ↓j`
>
> 
>
> 3.ConstDef`↓Attr_DataType` → Ident`↑Attr_Name` { '[' ConstExp ']' }`↓Attr_DataType ↑Attr_DataType`  '=' `@RunStackPush ↓j` ConstInitVal`↑c` `@insertSymbolList ↓Attr_DataType↓n↓c` 
>
> 4.VarDef`↓Attr_DataType` → Ident`↑Attr_Index` { '[' ConstExp ']' } | Ident `↑Attr_Index`  { '[' ConstExp ']' } '=' `@RunStackPush ↓j` InitVal`↑Attr_VInitValue` `@insertSymbolList ↓Attr_DataType↓Attr_Index↓Attr_VInitValue` 



若赋值变量是一个数组元素，编译程序先要生成调用计算数组元素地址的子程序，然后生成`LOD`指令,将该地址加载到操作数栈栈顶.



#### 控制语句

包括If语句，循环语句，*多分支语句（课下未涉及）*

##### if语句

对于if结构的处理主要是生成多条转移指令，以实现该结构所规定的控制流。

**改写成属性翻译文法**

> 'if' '( Cond ')' `@JPC↑y`Stmt `@labprod↓y`(ε| 'else' `@JMP↑z` `@labprod↓y` Stmt `@labprod↓z`) // 1.有else 2.⽆else 

<img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20211117195327168.png" alt="image-20211117195327168" style="zoom: 50%;" />

处理Cond所生成的目标代码是计算该条件表达式的值，并将其结果置于运行栈栈顶。如果栈顶值为假，则采用`JPC`指令控制跳转。

**动作程序实现**

```c++
if(SymbolList[CurSymPos] == IFTK){//IFTK
        Sym_map(SymbolList[CurSymPos]);
        CurSymPos = CurSymPos+1;

        /*还是在IntData中生成一个标号*/
        IntDataTable[IntDataTableTop++] = -1;
        ILable_inIntTabIndexA = IntDataTableTop-1;
        ILabStack.push_back(ILable_inIntTabIndexA);
        if(SymbolList[CurSymPos] == LPARENT){//LPARENT
            Sym_map(SymbolList[CurSymPos]);
            CurSymPos = CurSymPos+1;
            Cond();
            /*有条件跳转*/
            Sem_jpc(&IntDataTable[ILabStack[ILabStack.size()-1]]);//A

            if(SymbolList[CurSymPos] == RPARENT){//RPARENT
                Sym_map(SymbolList[CurSymPos]);
                CurSymPos = CurSymPos+1;
                Stmt();

                if(SymbolList[CurSymPos] == ELSETK){//ELSETK
                    /*还是在IntData中生成一个标号*/
                    IntDataTable[IntDataTableTop++] = -1;
                    ILable_inIntTabIndexB = IntDataTableTop-1;
                    ILabStack.push_back(ILable_inIntTabIndexB);

                    Sem_jmp(&IntDataTable[ILabStack[ILabStack.size()-1]]);//跳转到对应地址

                    Sem_gpi(&IntDataTable[ILabStack[ILabStack.size()-2]]);//便签回填

                    Sym_map(SymbolList[CurSymPos]);
                    CurSymPos = CurSymPos+1;
                    Stmt();
                    Sem_gpi(&IntDataTable[ILabStack[ILabStack.size()-1]]);//标签回填
                    ILabStack.pop_back();
                    ILabStack.pop_back();
                }
                else{
                    Sem_gpi(&IntDataTable[ILabStack[ILabStack.size()-1]]);
                    ILabStack.pop_back();
                }
            }
```



##### While语句

需要设置两个标号，lab1作为返回循环开头的标号，lab2作为循环结束跳转的标号

**改写成属性翻译文法**

> Stmt → 'while'  `@labgen↑r` '(' Cond ')' `@falsebranch↑f` Stmt `@retbranch↓r` `@labemit↓f`
>
> Stmt → 'break' ';' | 'continue' ';' 

**动作程序功能及其实现**

```c++
		IntDataTable[IntDataTableTop++] = PCodeList.size()-1;
        WLable_inIntTabIndexA = IntDataTableTop-1;//标签A
        WLabStack.push_back(WLable_inIntTabIndexA);
        IntDataTable[IntDataTableTop++] = PCodeList.size()-1;
        WLable_inIntTabIndexB = IntDataTableTop-1;//标签B
        WLabStack.push_back(WLable_inIntTabIndexB);//之前没有考虑好嵌套，需要利用一个存放标签的栈实现

        Sym_map(SymbolList[CurSymPos]);
        CurSymPos = CurSymPos+1;
        if(SymbolList[CurSymPos] == LPARENT){//LPARENT
            Sym_map(SymbolList[CurSymPos]);
            CurSymPos = CurSymPos+1;
            Cond();
            /*有条件跳转*/
            Sem_jpc(&IntDataTable[WLabStack[WLabStack.size()-1]]);//labb
            if(SymbolList[CurSymPos] == RPARENT){//RPARENT
                Sym_map(SymbolList[CurSymPos]);
                CurSymPos = CurSymPos+1;
                Stmt();
                Sem_jmp(&IntDataTable[WLabStack[WLabStack.size()-2]]);//跳转到laba
                Sem_gpi(&IntDataTable[WLabStack[WLabStack.size()-1]]);//回填labb的位置
                WLabStack.pop_back();
                WLabStack.pop_back();
            }
            else{
                Error(EJ);
                if(SymbolList[CurSymPos] == LBRACE){
                    SymTabLoc((int)StackSymbolTable.size());
                    Sem_dataStackLoc();
                }
                Stmt();
            }
        }
```



#### 函数调用和返回语句

本实验函数调用时，形参和实参之间的数据传递方式通过传值形式实现。调用函数的目标程序段，把实参的值计算出来，并存放在运行栈中。被调用段将实参的值传进形参的数据单元中。

第一次实现函数调用利用语法分析中构造的符号表，没有清晰的辨别编译和执行两个过程，导致最后函数递归的时候，不能进行函数的嵌套，新的一层符号表会将旧的一层符号表覆盖。经过思考后，选择构造一个数据栈存放变量名、函数地址、数组模板表、等内容，保证了函数递归使用的正常运行。



#### 数组实现

对每个数组构造一个数组模板表，如下。声明时填入对应的上下界值，并计算出对应的pi。调用时通过找对应模板表的内容利用数组地址计算公式，计算出数组元素所在数组元素存储区的位置，进行调用。

作为函数传参时，传递的是数组的数组模板表。

```
/*        ______
 *  ->TOP| P(2) |
 *       | U(2) |
 *       |  0   |
 *       | P(1) |
 *       | U(1) |
 *       |  0   |
 *       | Begin|
 *       | dim  |
 *       --------
 */
```



#### 输入输出语句

##### 1.输入语句

输入语句真的给我带来的很大痛苦，因为使用了freopen导致scanf读数据的时候，会将一部分数据读到文本中，导致奇怪的中断。

##### 2.输出语句

两个指令实现、replace将%d对应的数据修改为字符串形式进行替换。output直接输出修改完后的字符串。

#### 存储区的实现

`DataStack`

```
struct DataTable{
    DataTable(
        int _NameIndex,
        int _FuncIndex,
        int _ArrayTempIndex,
        int _Value
    ) :
        NameIndex(_NameIndex),
        FuncIndex(_FuncIndex),
        ArrayTempIndex(_ArrayTempIndex),
        Value(_Value){}
    int NameIndex;//传TokenList 的i位
    int FuncIndex;//函数在PcodeList的下标,是函数时才赋值
    int ArrayTempIndex;
    int Value;//变量值
};
```

`RunStack`

```
vector<int> RunStack;
```



### PCode表



| 助记符              | 是否在函数体中 | 目标地址                             | 功能                                                         | 实现过程 |
| ------------------- | -------------- | ------------------------------------ | ------------------------------------------------------------ | -------- |
| P_ORR               |                |                                      | 整形或                                                       |          |
| P_AND               |                |                                      | 整形与                                                       |          |
| P_EQL               |                |                                      | 判断相等                                                     |          |
| P_NEQ               |                |                                      | 判断不等                                                     |          |
| P_LSS               |                |                                      | 判断小于                                                     |          |
| P_LEQ               |                |                                      | 判断小于等于                                                 |          |
| P_GRE               |                |                                      | 判断大于                                                     |          |
| P_GEQ               |                |                                      | 判断大于等于                                                 |          |
| P_ADD               |                |                                      | 整形加                                                       |          |
| P_SUB               |                |                                      | 整形减                                                       |          |
| P_MUL               |                |                                      | 整形乘                                                       |          |
| P_DIV               |                |                                      | 整形除                                                       |          |
| P_MOD               |                |                                      | 取模                                                         |          |
| P_NOT               |                |                                      | 取反                                                         |          |
| P_LOADI             |                | 存放**立即数**的数据存储区地址       | 加载地址对应的**立即数**到运行栈栈顶                         |          |
| P_LOAD              |                | 存放**变量**的数据存储区地址         | 加载地址对应**变量值**到运行栈栈顶                           |          |
| P_STO               |                | 赋值变量的目标地址                   | 赋值                                                         |          |
| P_STOINT_PARAM      |                | 相当于一个循环变量                   | 给int型形参赋值                                              |          |
| P_STOARY_PARAM      |                | 相当于一个循环变量                   | 给数组形参赋值                                               |          |
| P_INPUT             |                |                                      | 从键盘输入                                                   |          |
| P_REPLACE           |                | %d对应的变量目标地址                 | 将输出字符串的%d替换成对应值                                 |          |
| P_OUTPUT            |                | 字符串所在tokenlist的位置            | 输出字符串                                                   |          |
| P_JPC               |                | 跳转位置在数据区的目标地址           | 如果栈顶值为0，跳转到                                        |          |
| P_JMP               |                | 跳转位置在数据区的目标地址           | 无条件跳转                                                   |          |
| P_JSR               |                | 函数体的开始pcodlist对应的下标       | 函数调用跳转到函数体开始位置                                 |          |
| P_GPI               |                | 标签的目标地址                       | 反填标签位置                                                 |          |
| P_TOPLUS            |                |                                      | 取正                                                         |          |
| P_TOMINU            |                |                                      | 取负                                                         |          |
| P_GETTOP            |                | 提取元素将要赋给的变量目标地址       | 获得栈顶元素                                                 |          |
| P_STOP              |                |                                      | 停止执行函数中指令                                           |          |
| P_RETURN            |                | 调用位置的目标地址                   | 返回函数调用位置                                             |          |
| P_STR               |                | 返回地址的目标地址                   | 存储函数调用返回位置                                         |          |
| P_INITARY_TEMPBEGIN |                | 存放在数据存储取得模板表位置         | 在执行时初始化模板表                                         |          |
| P_INITARY_TEMPLVUP  |                | 存放在数据存储取得模板表位置         | 在执行时初始化模板表上下界以及pi                             |          |
| P_INITCARY_SAREA    |                | 初始化有初始值数组对应数组存储的长度 | 初始化有初值的数组模板                                       |          |
| P_INITVARY_SAREA    |                | 初始化无初始值数组对应数组存储的长度 | 初始化有无初值的数组模板                                     |          |
| P_GETARY_BEGIN      |                |                                      | 获得数组模板表中的数组开始地址块内容                         |          |
| P_NEWARY_TEMP       |                |                                      | 根据二维数组，新建一个临时模板表，提供给形参的一维数组       |          |
| P_LOADARY_TEMP      |                |                                      | 加载元素到存储区中                                           |          |
| P_LOADARY_PI        |                | 对应数组模板表所在位置的目标地址     | 加载数组模板中的P(i)                                         |          |
| P_LOADARY_BEGIN     |                | 对应数组模板表所在位置的目标地址     | 加载数组模板中的开始地址                                     |          |
| P_GETARY_PI         |                | 对应数组模板表所在位置的目标地址     | 计算数组模板中的P(i)                                         |          |
| P_SWP               |                |                                      | 交换运行栈顶和次栈顶                                         |          |
| P_GETARY_TEMPBEGIN  |                | 模板表在temparea的位置的目标地址     | 获得模板表在temparea的位置                                   |          |
| P_GETARY_VAL        |                |                                      | 将栈顶值作为索引获得IntData存储中的值， 其实就是获得数组对应元素 |          |
| P_LOADARY_ELM       |                |                                      | 加载元素到存储区中                                           |          |
| P_STOARY            |                |                                      | 对数组元素赋值                                               |          |
| P_DATA_INSERT       |                |                                      | 插入数据栈                                                   |          |
| P_DATA_FIND         |                |                                      | 查找数据栈                                                   |          |
| P_DATA_LOC          |                |                                      | 定位数据栈层数                                               |          |
| P_DATA_RELOC        |                |                                      | 重定位数据栈                                                 |          |
| P_DATA_FUNC_LOC     |                |                                      | 函数数据栈定位                                               |          |
| P_DATA_FUNC_RELOC   |                |                                      | 函数数据栈重定位                                             |          |
| P_LOAD_DATA_INDEX   |                |                                      | 获取数据栈对应下标的元素的值，加载到运行栈中                 |          |
| P_LOAD_REPEAT       |                |                                      | 将栈顶元素再pushback到新栈顶                                 |          |



